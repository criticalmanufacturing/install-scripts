## @param global.imageRegistry Global Docker image registry
## @param global.imagePullSecrets Global Docker registry secret names as an array
## @param global.defaultStorageClass Global default StorageClass for Persistent Volume(s)
## @param global.storageClass DEPRECATED: use global.defaultStorageClass instead
##
global:
  imageRegistry: ""
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []
  defaultStorageClass: ""
  storageClass: ""
  ## Compatibility adaptations for Kubernetes platforms
  ##
  compatibility:
    ## Compatibility adaptations for Openshift
    ##
    openshift:
      ## @param global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: auto (apply if the detected running cluster is Openshift), force (perform the adaptation always), disabled (do not perform adaptation)
      ##
      adaptSecurityContext: auto

## @param nameOverride String to partially override common.names.fullname
##
nameOverride: ""
## @param fullnameOverride String to fully override common.names.fullname
##
fullnameOverride: "kafka-test"
## @param clusterDomain Default Kubernetes cluster domain
##
clusterDomain: cluster.local
## @param serviceBindings.enabled Create secret for service binding (Experimental)
## Ref: https://servicebinding.io/service-provider/
##
serviceBindings:
  enabled: false

## Bitnami Kafka image version
## ref: https://hub.docker.com/r/bitnami/kafka/tags/
## @param image.registry [default: REGISTRY_NAME] Kafka image registry
## @param image.repository [default: REPOSITORY_NAME/kafka] Kafka image repository
## @skip image.tag Kafka image tag (immutable tags are recommended)
## @param image.digest Kafka image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
## @param image.pullPolicy Kafka image pull policy
## @param image.pullSecrets Specify docker-registry secret names as an array
## @param image.debug Specify if debug values should be set
##
image:
  registry: docker.io
  repository: bitnami/kafka
  tag: 3.8.0-debian-12-r3
  digest: ""
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
  ##
  pullPolicy: IfNotPresent
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ## e.g:
  ## pullSecrets:
  ##   - myRegistryKeySecretName
  ##
  pullSecrets: []
  ## Set to true if you would like to see extra information on logs
  ##
  debug: true

## @param extraInit Additional content for the kafka init script, rendered as a template.
##
extraInit: ""
## @param config Configuration file for Kafka, rendered as a template. Auto-generated based on chart values when not specified.
## @param existingConfigmap ConfigMap with Kafka Configuration
## NOTE: This will override the configuration based on values, please act carefully
## If both are set, the existingConfigMap will be used.
##
config: ""
existingConfigmap: ""
## @param extraConfig Additional configuration to be appended at the end of the generated Kafka configuration file.
##
extraConfig: ""
## @param extraConfigYaml Additional configuration in yaml format to be appended at the end of the generated Kafka configuration file.
##
## E.g.
## extraConfigYaml:
##   default.replication.factor: 3
##
extraConfigYaml: {}
## @param secretConfig Additional configuration to be appended at the end of the generated Kafka configuration file.
## This value will be stored in a secret.
##
secretConfig: ""
## @param existingSecretConfig Secret with additonal configuration that will be appended to the end of the generated Kafka configuration file
## The key for the configuration should be: server-secret.properties
## NOTE: This will override secretConfig value
##
existingSecretConfig: ""
## @param log4j An optional log4j.properties file to overwrite the default of the Kafka brokers
## An optional log4j.properties file to overwrite the default of the Kafka brokers
## ref: https://github.com/apache/kafka/blob/trunk/config/log4j.properties
##
log4j: ""
## @param existingLog4jConfigMap The name of an existing ConfigMap containing a log4j.properties file
## The name of an existing ConfigMap containing a log4j.properties file
## NOTE: this will override `log4j`
##
existingLog4jConfigMap: ""
## @param heapOpts Kafka Java Heap size
##
heapOpts: -Xmx1024m -Xms1024m
## @param brokerRackAssignment Set Broker Assignment for multi tenant environment Allowed values: `aws-az`
## ref: https://cwiki.apache.org/confluence/display/KAFKA/KIP-392%3A+Allow+consumers+to+fetch+from+closest+replica
##
brokerRackAssignment: ""
## @param interBrokerProtocolVersion Override the setting 'inter.broker.protocol.version' during the ZK migration.
## Ref. https://docs.confluent.io/platform/current/installation/migrate-zk-kraft.html
##
interBrokerProtocolVersion: ""
## Kafka listeners configuration
##
listeners:
  ## @param listeners.client.name Name for the Kafka client listener
  ## @param listeners.client.containerPort Port for the Kafka client listener
  ## @param listeners.client.protocol Security protocol for the Kafka client listener. Allowed values are 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
  ## @param listeners.client.sslClientAuth Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If SSL protocol is enabled, overrides tls.authType for this listener. Allowed values are 'none', 'requested' and 'required'
  client:
    name: CLIENT
    containerPort: 9092
    protocol: SASL_SSL
    sslClientAuth: ""
  ## @param listeners.controller.name Name for the Kafka controller listener
  ## @param listeners.controller.containerPort Port for the Kafka controller listener
  ## @param listeners.controller.protocol Security protocol for the Kafka controller listener. Allowed values are 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
  ## @param listeners.controller.sslClientAuth Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If SSL protocol is enabled, overrides tls.authType for this listener. Allowed values are 'none', 'requested' and 'required'
  ## Ref: https://cwiki.apache.org/confluence/display/KAFKA/KIP-684+-+Support+mutual+TLS+authentication+on+SASL_SSL+listeners
  controller:
    name: CONTROLLER
    containerPort: 9093
    protocol: SASL_PLAINTEXT
    sslClientAuth: ""
  ## @param listeners.interbroker.name Name for the Kafka inter-broker listener
  ## @param listeners.interbroker.containerPort Port for the Kafka inter-broker listener
  ## @param listeners.interbroker.protocol Security protocol for the Kafka inter-broker listener. Allowed values are 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
  ## @param listeners.interbroker.sslClientAuth Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If SSL protocol is enabled, overrides tls.authType for this listener. Allowed values are 'none', 'requested' and 'required'
  interbroker:
    name: INTERNAL
    containerPort: 9094
    protocol: SASL_PLAINTEXT
    sslClientAuth: ""
  ## @param listeners.external.containerPort Port for the Kafka external listener
  ## @param listeners.external.protocol Security protocol for the Kafka external listener. . Allowed values are 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
  ## @param listeners.external.name Name for the Kafka external listener
  ## @param listeners.external.sslClientAuth Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If SSL protocol is enabled, overrides tls.sslClientAuth for this listener. Allowed values are 'none', 'requested' and 'required'
  external:
    name: EXTERNAL
    containerPort: 9095
    protocol: SASL_PLAINTEXT
    sslClientAuth: ""
  ## @param listeners.extraListeners Array of listener objects to be appended to already existing listeners
  ## E.g.
  ## extraListeners:
  ##  - name: CUSTOM
  ##    containerPort: 9097
  ##    protocol: SASL_PLAINTEXT
  ##    sslClientAuth: ""
  ##
  extraListeners: []
  ## NOTE: If set, below values will override configuration set using the above values (extraListeners.*, controller.*, interbroker.*, client.* and external.*)
  ## @param listeners.overrideListeners Overrides the Kafka 'listeners' configuration setting.
  ## @param listeners.advertisedListeners Overrides the Kafka 'advertised.listener' configuration setting.
  ## @param listeners.securityProtocolMap Overrides the Kafka 'security.protocol.map' configuration setting.
  overrideListeners: ""
  advertisedListeners: "CLIENT://localhost:32125,INTERNAL://localhost:9094"
  securityProtocolMap: ""

## @section Kafka SASL parameters
## Kafka SASL settings for authentication, required if SASL_PLAINTEXT or SASL_SSL listeners are configured
##
sasl:
  ## @param sasl.enabledMechanisms Comma-separated list of allowed SASL mechanisms when SASL listeners are configured. Allowed types: `PLAIN`, `SCRAM-SHA-256`, `SCRAM-SHA-512`, `OAUTHBEARER`
  ## NOTE: At the moment, Kafka Raft mode does not support SCRAM, that is why only PLAIN is configured.
  ##
  enabledMechanisms: PLAIN,SCRAM-SHA-256,SCRAM-SHA-512
  ## @param sasl.interBrokerMechanism SASL mechanism for inter broker communication.
  ##
  interBrokerMechanism: PLAIN
  ## @param sasl.controllerMechanism SASL mechanism for controller communications.
  ##
  controllerMechanism: PLAIN
  ## Settings for oauthbearer mechanism
  ## @param sasl.oauthbearer.tokenEndpointUrl The URL for the OAuth/OIDC identity provider
  ## @param sasl.oauthbearer.jwksEndpointUrl The OAuth/OIDC provider URL from which the provider's JWKS (JSON Web Key Set) can be retrieved
  ## @param sasl.oauthbearer.expectedAudience The comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences
  ## @param sasl.oauthbearer.subClaimName The OAuth claim name for the subject.
  ##
  oauthbearer:
    tokenEndpointUrl: ""
    jwksEndpointUrl: ""
    expectedAudience: ""
    subClaimName: "sub"
  ## Credentials for inter-broker communications.
  ## @param sasl.interbroker.user Username for inter-broker communications when SASL is enabled
  ## @param sasl.interbroker.password Password for inter-broker communications when SASL is enabled. If not set and SASL is enabled for the controller listener, a random password will be generated.
  ## @param sasl.interbroker.clientId Client ID for inter-broker communications when SASL is enabled with mechanism OAUTHBEARER
  ## @param sasl.interbroker.clientSecret Client Secret for inter-broker communications when SASL is enabled with mechanism OAUTHBEARER. If not set and SASL is enabled for the controller listener, a random secret will be generated.
  ##
  interbroker:
    user: inter_broker_user
    password: ""
    clientId: inter_broker_client
    clientSecret: ""
  ## Credentials for controller communications.
  ## @param sasl.controller.user Username for controller communications when SASL is enabled
  ## @param sasl.controller.password Password for controller communications when SASL is enabled. If not set and SASL is enabled for the inter-broker listener, a random password will be generated.
  ## @param sasl.controller.clientId Client ID for controller communications when SASL is enabled with mechanism OAUTHBEARER
  ## @param sasl.controller.clientSecret Client Secret for controller communications when SASL is enabled with mechanism OAUTHBEARER. If not set and SASL is enabled for the inter-broker listener, a random secret will be generated.
  ##
  controller:
    user: controller_user
    password: ""
    clientId: controller_broker_client
    clientSecret: ""
  ## Credentials for client communications.
  ## @param sasl.client.users Comma-separated list of usernames for client communications when SASL is enabled
  ## @param sasl.client.passwords Comma-separated list of passwords for client communications when SASL is enabled, must match the number of client.users
  ##
  client:
    users:
      - default
    passwords: "defaultPassword"
  ## @param sasl.existingSecret Name of the existing secret containing credentials for clientUsers, interBrokerUser, controllerUser and zookeeperUser
  ## Create this secret running the command below where SECRET_NAME is the name of the secret you want to create:
  ##       kubectl create secret generic SECRET_NAME --from-literal=client-passwords=CLIENT_PASSWORD1,CLIENT_PASSWORD2 --from-literal=inter-broker-password=INTER_BROKER_PASSWORD --from-literal=inter-broker-client-secret=INTER_BROKER_CLIENT_SECRET --from-literal=controller-password=CONTROLLER_PASSWORD --from-literal=controller-client-secret=CONTROLLER_CLIENT_SECRET --from-literal=zookeeper-password=ZOOKEEPER_PASSWORD
  ## The client secrets are only required when using oauthbearer as sasl mechanism.
  ## Client, interbroker and controller passwords are only required if the sasl mechanism includes something other than oauthbearer.
  ##
  existingSecret: ""
## @section Kafka TLS parameters
## Kafka TLS settings, required if SSL or SASL_SSL listeners are configured
##
tls:
  ## @param tls.type Format to use for TLS certificates. Allowed types: `JKS` and `PEM`
  ##
  type: JKS
  ## @param tls.pemChainIncluded Flag to denote that the Certificate Authority (CA) certificates are bundled with the endpoint cert.
  ## Certificates must be in proper order, where the top certificate is the leaf and the bottom certificate is the top-most intermediate CA.
  ##
  pemChainIncluded: false
  ## @param tls.existingSecret Name of the existing secret containing the TLS certificates for the Kafka nodes.
  ## When using 'jks' format for certificates, each secret should contain a truststore and a keystore.
  ## Create these secrets following the steps below:
  ## 1) Generate your truststore and keystore files. Helpful script: https://raw.githubusercontent.com/confluentinc/confluent-platform-security-tools/master/kafka-generate-ssl.sh
  ## 2) Rename your truststore to `kafka.truststore.jks`.
  ## 3) Rename your keystores to `kafka-<role>-X.keystore.jks` where X is the replica number of the .
  ## 4) Run the command below one time per broker to create its associated secret (SECRET_NAME_X is the name of the secret you want to create):
  ##      kubectl create secret generic SECRET_NAME_0 --from-file=kafka.truststore.jks=./kafka.truststore.jks \
  ##        --from-file=kafka-controller-0.keystore.jks=./kafka-controller-0.keystore.jks --from-file=kafka-broker-0.keystore.jks=./kafka-broker-0.keystore.jks ...
  ##
  ## NOTE: Alternatively, a single keystore can be provided for all nodes under the key 'kafka.keystore.jks', this keystore will be used by all nodes unless overridden by the 'kafka-<role>-X.keystore.jks' file
  ##
  ## When using 'pem' format for certificates, each secret should contain a public CA certificate, a public certificate and one private key.
  ## Create these secrets following the steps below:
  ## 1) Create a certificate key and signing request per Kafka broker, and sign the signing request with your CA
  ## 2) Rename your CA file to `kafka.ca.crt`.
  ## 3) Rename your certificates to `kafka-X.tls.crt` where X is the ID of each Kafka broker.
  ## 3) Rename your keys to `kafka-X.tls.key` where X is the ID of each Kafka broker.
  ## 4) Run the command below one time per broker to create its associated secret (SECRET_NAME_X is the name of the secret you want to create):
  ##      kubectl create secret generic SECRET_NAME_0 --from-file=kafka-ca.crt=./kafka-ca.crt --from-file=kafka-controller-0.crt=./kafka-controller-0.crt --from-file=kafka-controller-0.key=./kafka-controller-0.key \
  ##        --from-file=kafka-broker-0.crt=./kafka-broker-0.crt --from-file=kafka-broker-0.key=./kafka-broker-0.key ...
  ##
  ## NOTE: Alternatively, a single key and certificate can be provided for all nodes under the keys 'kafka.crt' and 'kafka.key'. These certificates will be used by all nodes unless overridden by the 'kafka-<role>-X.key' and 'kafka-<role>-X.crt' files
  ## NOTE: Alternatively, a single key and certificate can be provided for all nodes under the keys 'tls.crt' and 'tls.key'. These certificates will be used by all nodes unless overridden by the 'kafka-<role>-X.key' and 'kafka-<role>-X.crt' files
  ##
  existingSecret: ""
  ## @param tls.autoGenerated Generate automatically self-signed TLS certificates for Kafka brokers. Currently only supported if `tls.type` is `PEM`
  ## Note: ignored when using 'jks' format or `tls.existingSecret` is not empty
  ##
  autoGenerated: true
  ## @param tls.customAltNames Optionally specify extra list of additional subject alternative names (SANs) for the automatically generated TLS certificates.
  ##
  customAltNames: []
  ## @param tls.passwordsSecret Name of the secret containing the password to access the JKS files or PEM key when they are password-protected. (`key`: `password`)
  ##
  passwordsSecret: ""
  ## @param tls.passwordsSecretKeystoreKey The secret key from the tls.passwordsSecret containing the password for the Keystore.
  ##
  passwordsSecretKeystoreKey: keystore-password
  ## @param tls.passwordsSecretTruststoreKey The secret key from the tls.passwordsSecret containing the password for the Truststore.
  ##
  passwordsSecretTruststoreKey: truststore-password
  ## @param tls.passwordsSecretPemPasswordKey The secret key from the tls.passwordsSecret containing the password for the PEM key inside 'tls.passwordsSecret'.
  ##
  passwordsSecretPemPasswordKey: ""
  ## @param tls.keystorePassword Password to access the JKS keystore when it is password-protected. Ignored when 'tls.passwordsSecret' is provided.
  ## When using tls.type=PEM, the generated keystore will use this password or randomly generate one.
  ##
  keystorePassword: ""
  ## @param tls.truststorePassword Password to access the JKS truststore when it is password-protected. Ignored when 'tls.passwordsSecret' is provided.
  ## When using tls.type=PEM, the generated keystore will use this password or randomly generate one.
  ##
  truststorePassword: ""
  ## @param tls.keyPassword Password to access the PEM key when it is password-protected.
  ## Note: ignored when using 'tls.passwordsSecret'
  ##
  keyPassword: ""
  ## @param tls.jksKeystoreKey The secret key from the `tls.existingSecret` containing the keystore
  ## Note: ignored when using 'pem' format for certificates.
  ##
  jksKeystoreKey: ""
  ## @param tls.jksTruststoreSecret Name of the existing secret containing your truststore if truststore not existing or different from the one in the `tls.existingSecret`
  ## Note: ignored when using 'pem' format for certificates.
  ##
  jksTruststoreSecret: ""
  ## @param tls.jksTruststoreKey The secret key from the `tls.existingSecret` or `tls.jksTruststoreSecret` containing the truststore
  ## Note: ignored when using 'pem' format for certificates.
  ##
  jksTruststoreKey: ""
  ## @param tls.endpointIdentificationAlgorithm The endpoint identification algorithm to validate server hostname using server certificate
  ## Disable server host name verification by setting it to an empty string.
  ## ref: https://docs.confluent.io/current/kafka/authentication_ssl.html#optional-settings
  ##
  endpointIdentificationAlgorithm: https
  ## @param tls.sslClientAuth Sets the default value for the ssl.client.auth Kafka setting.
  ## ref: https://docs.confluent.io/current/kafka/authentication_ssl.html#optional-settings
  ##
  sslClientAuth: "required"

controller:
  ## @param controller.replicaCount Number of Kafka controller-eligible nodes
  ## Ignore this section if running in Zookeeper mode.
  ##
  replicaCount: 3
  resourcesPreset: "small"
  ## @param controller.resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
  ## Example:
  ## resources:
  ##   requests:
  ##     cpu: 2
  ##     memory: 512Mi
  ##   limits:
  ##     cpu: 3
  ##     memory: 1024Mi
  ##
  ## resources: {}
  ## Kafka pods' Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param controller.podSecurityContext.enabled Enable security context for the pods
  ## @param controller.podSecurityContext.fsGroupChangePolicy Set filesystem group change policy
  ## @param controller.podSecurityContext.sysctls Set kernel settings using the sysctl interface
  ## @param controller.podSecurityContext.supplementalGroups Set filesystem extra groups
  ## @param controller.podSecurityContext.fsGroup Set Kafka pod's Security Context fsGroup
  ## @param controller.podSecurityContext.seccompProfile.type Set Kafka pods's Security Context seccomp profile
  ##
  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001
    seccompProfile:
      type: "RuntimeDefault"
  ## Kafka containers' Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  ## @param controller.containerSecurityContext.enabled Enable Kafka containers' Security Context
  ## @param controller.containerSecurityContext.seLinuxOptions [object,nullable] Set SELinux options in container
  ## @param controller.containerSecurityContext.runAsUser Set containers' Security Context runAsUser
  ## @param controller.containerSecurityContext.runAsGroup Set containers' Security Context runAsGroup
  ## @param controller.containerSecurityContext.runAsGroup Set Kafka containers' Security Context runAsGroup
  ## @param controller.containerSecurityContext.runAsNonRoot Set Kafka containers' Security Context runAsNonRoot
  ## @param controller.containerSecurityContext.allowPrivilegeEscalation Force the child process to be run as non-privileged
  ## @param controller.containerSecurityContext.readOnlyRootFilesystem Allows the pod to mount the RootFS as ReadOnly only
  ## @param controller.containerSecurityContext.capabilities.drop Set Kafka containers' server Security Context capabilities to be dropped
  ## e.g:
  ##   containerSecurityContext:
  ##     enabled: true
  ##     capabilities:
  ##       drop: ["NET_RAW"]
  ##     readOnlyRootFilesystem: true
  ##
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop: ["ALL"]
  ## @param controller.updateStrategy.type Kafka statefulset strategy type
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    type: RollingUpdate
  persistence:
    ## @param controller.persistence.enabled Enable Kafka data persistence using PVC, note that ZooKeeper persistence is unaffected
    ##
    enabled: true
    ## @param controller.persistence.existingClaim A manually managed Persistent Volume and Claim
    ## If defined, PVC must be created manually before volume will be bound
    ## The value is evaluated as a template
    ##
    existingClaim: ""
    ## @param controller.persistence.storageClass PVC Storage Class for Kafka data volume
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ## set, choosing the default provisioner.
    ##
    storageClass: ""
    ## @param controller.persistence.accessModes Persistent Volume Access Modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param controller.persistence.size PVC Storage Request for Kafka data volume
    ##
    size: 8Gi
    ## @param controller.persistence.annotations Annotations for the PVC
    ##
    annotations: {}
    ## @param controller.persistence.labels Labels for the PVC
    ##
    labels: {}
    ## @param controller.persistence.selector Selector to match an existing Persistent Volume for Kafka data PVC. If set, the PVC can't have a PV dynamically provisioned for it
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param controller.persistence.mountPath Mount path of the Kafka data volume
    ##
    mountPath: /bitnami/kafka
  ## Log Persistence parameters
  ##
  logPersistence:
    ## @param controller.logPersistence.enabled Enable Kafka logs persistence using PVC, note that ZooKeeper persistence is unaffected
    ##
    enabled: false
    ## @param controller.logPersistence.existingClaim A manually managed Persistent Volume and Claim
    ## If defined, PVC must be created manually before volume will be bound
    ## The value is evaluated as a template
    ##
    existingClaim: ""
    ## @param controller.logPersistence.storageClass PVC Storage Class for Kafka logs volume
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ## set, choosing the default provisioner.
    ##
    storageClass: ""
    ## @param controller.logPersistence.accessModes Persistent Volume Access Modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param controller.logPersistence.size PVC Storage Request for Kafka logs volume
    ##
    size: 8Gi
    ## @param controller.logPersistence.annotations Annotations for the PVC
    ##
    annotations: {}
    ## @param controller.logPersistence.selector Selector to match an existing Persistent Volume for Kafka log data PVC. If set, the PVC can't have a PV dynamically provisioned for it
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param controller.logPersistence.mountPath Mount path of the Kafka logs volume
    ##
    mountPath: /opt/bitnami/kafka/logs
## @section Broker-only statefulset parameters
##
broker:
  ## Kafka resource requests and limits
  ## ref: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  ## @param broker.resourcesPreset Set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if broker.resources is set (broker.resources is recommended for production).
  ## More information: https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15
  ##
  resourcesPreset: "small"
  ## @param broker.resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
  ## Example:
  ## resources:
  ##   requests:
  ##     cpu: 2
  ##     memory: 512Mi
  ##   limits:
  ##     cpu: 3
  ##     memory: 1024Mi
  ##
  ## resources: {}
  ## Kafka pods' Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param broker.podSecurityContext.enabled Enable security context for the pods
  ## @param broker.podSecurityContext.fsGroupChangePolicy Set filesystem group change policy
  ## @param broker.podSecurityContext.sysctls Set kernel settings using the sysctl interface
  ## @param broker.podSecurityContext.supplementalGroups Set filesystem extra groups
  ## @param broker.podSecurityContext.fsGroup Set Kafka pod's Security Context fsGroup
  ## @param broker.podSecurityContext.seccompProfile.type Set Kafka pod's Security Context seccomp profile
  ##
  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001
    seccompProfile:
      type: "RuntimeDefault"
  ## Kafka containers' Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  ## @param broker.containerSecurityContext.enabled Enable Kafka containers' Security Context
  ## @param broker.containerSecurityContext.seLinuxOptions [object,nullable] Set SELinux options in container
  ## @param broker.containerSecurityContext.runAsUser Set containers' Security Context runAsUser
  ## @param broker.containerSecurityContext.runAsGroup Set containers' Security Context runAsGroup
  ## @param broker.containerSecurityContext.runAsNonRoot Set Kafka containers' Security Context runAsNonRoot
  ## @param broker.containerSecurityContext.allowPrivilegeEscalation Force the child process to be run as non-privileged
  ## @param broker.containerSecurityContext.readOnlyRootFilesystem Allows the pod to mount the RootFS as ReadOnly only
  ## @param broker.containerSecurityContext.capabilities.drop Set Kafka containers' server Security Context capabilities to be dropped
  ## e.g:
  ##   containerSecurityContext:
  ##     enabled: true
  ##     capabilities:
  ##       drop: ["NET_RAW"]
  ##     readOnlyRootFilesystem: true
  ##
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop: ["ALL"]
  ## @param broker.automountServiceAccountToken Mount Service Account token in pod
  ##
  automountServiceAccountToken: false
  updateStrategy:
    type: RollingUpdate
  ## Enable persistence using Persistent Volume Claims
  ## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
  ##
  persistence:
    ## @param broker.persistence.enabled Enable Kafka data persistence using PVC, note that ZooKeeper persistence is unaffected
    ##
    enabled: true
    ## @param broker.persistence.existingClaim A manually managed Persistent Volume and Claim
    ## If defined, PVC must be created manually before volume will be bound
    ## The value is evaluated as a template
    ##
    existingClaim: ""
    ## @param broker.persistence.storageClass PVC Storage Class for Kafka data volume
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ## set, choosing the default provisioner.
    ##
    storageClass: ""
    ## @param broker.persistence.accessModes Persistent Volume Access Modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param broker.persistence.size PVC Storage Request for Kafka data volume
    ##
    size: 8Gi
    ## @param broker.persistence.annotations Annotations for the PVC
    ##
    annotations: {}
    ## @param broker.persistence.labels Labels for the PVC
    ##
    labels: {}
    ## @param broker.persistence.selector Selector to match an existing Persistent Volume for Kafka data PVC. If set, the PVC can't have a PV dynamically provisioned for it
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param broker.persistence.mountPath Mount path of the Kafka data volume
    ##
    mountPath: /bitnami/kafka
  ## Log Persistence parameters
  ##
  logPersistence:
    ## @param broker.logPersistence.enabled Enable Kafka logs persistence using PVC, note that ZooKeeper persistence is unaffected
    ##
    enabled: false
    ## @param broker.logPersistence.existingClaim A manually managed Persistent Volume and Claim
    ## If defined, PVC must be created manually before volume will be bound
    ## The value is evaluated as a template
    ##
    existingClaim: ""
    ## @param broker.logPersistence.storageClass PVC Storage Class for Kafka logs volume
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ## set, choosing the default provisioner.
    ##
    storageClass: ""
    ## @param broker.logPersistence.accessModes Persistent Volume Access Modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param broker.logPersistence.size PVC Storage Request for Kafka logs volume
    ##
    size: 8Gi
    ## @param broker.logPersistence.annotations Annotations for the PVC
    ##
    annotations: {}
    ## @param broker.logPersistence.selector Selector to match an existing Persistent Volume for Kafka log data PVC. If set, the PVC can't have a PV dynamically provisioned for it
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param broker.logPersistence.mountPath Mount path of the Kafka logs volume
    ##
    mountPath: /opt/bitnami/kafka/logs

## Service parameters
##
service:
  ## @param service.type Kubernetes Service type
  ##
  type: NodePort
  ## @param service.ports.client Kafka svc port for client connections
  ## @param service.ports.controller Kafka svc port for controller connections. It is used if "kraft.enabled: true"
  ## @param service.ports.interbroker Kafka svc port for inter-broker connections
  ## @param service.ports.external Kafka svc port for external connections
  ##
  ports:
    client: 9092
    controller: 9093
    interbroker: 9094
    external: 9095
  ## @param service.nodePorts.client Node port for the Kafka client connections
  ## @param service.nodePorts.external Node port for the Kafka external connections
  ## NOTE: choose port between <30000-32767>
  ##
  nodePorts:
    client: "32125"
    external: "32126"

## ServiceAccount for Kafka
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
##
serviceAccount:
  ## @param serviceAccount.create Enable creation of ServiceAccount for Kafka pods
  ##
  create: true
  ## @param serviceAccount.name The name of the service account to use. If not set and `create` is `true`, a name is generated
  ## If not set and create is true, a name is generated using the kafka.serviceAccountName template
  ##
  name: ""
  ## @param serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
  ## Can be set to false if pods using this serviceAccount do not need to use K8s API
  ##
  automountServiceAccountToken: false
  ## @param serviceAccount.annotations Additional custom annotations for the ServiceAccount
  ##
  annotations: {}
## Role Based Access Control
## ref: https://kubernetes.io/docs/admin/authorization/rbac/
##
rbac:
  ## @param rbac.create Whether to create & use RBAC resources or not
  ## binding Kafka ServiceAccount to a role
  ## that allows Kafka pods querying the K8s API
  ##
  create: false

## Kafka provisioning
##
provisioning:
  ## @param provisioning.enabled Enable kafka provisioning Job
  ##
  enabled: false
  ## @param provisioning.automountServiceAccountToken Mount Service Account token in pod
  ##
  automountServiceAccountToken: false
  ## @param provisioning.numPartitions Default number of partitions for topics when unspecified
  ##
  numPartitions: 3
  ## @param provisioning.replicationFactor Default replication factor for topics when unspecified
  ##
  replicationFactor: 3
  ## Auth Configuration for kafka provisioning Job
  ##
  auth:
    ## TLS configuration for kafka provisioning Job
    ##
    tls:
      ## @param provisioning.auth.tls.type Format to use for TLS certificates. Allowed types: `JKS` and `PEM`.
      ## Note: ignored if auth.tls.client.protocol different from one of these values: "SSL" "SASL_SSL"
      ##
      type: JKS
      ## @param provisioning.auth.tls.certificatesSecret Existing secret containing the TLS certificates for the Kafka provisioning Job.
      ## When using 'jks' format for certificates, the secret should contain a truststore and a keystore.
      ## When using 'pem' format for certificates, the secret should contain one of the following:
      ## 1. A public CA certificate, a public certificate and one private key.
      ## 2. A truststore and a keystore in PEM format
      ## If caCert is set, option 1 will be taken, otherwise option 2.
      ##
      certificatesSecret: ""
      ## @param provisioning.auth.tls.cert The secret key from the certificatesSecret if 'cert' key different from the default (tls.crt)
      ##
      cert: tls.crt
      ## @param provisioning.auth.tls.key The secret key from the certificatesSecret if 'key' key different from the default (tls.key)
      ##
      key: tls.key
      ## @param provisioning.auth.tls.caCert The secret key from the certificatesSecret if 'caCert' key different from the default (ca.crt)
      ##
      caCert: ca.crt
      ## @param provisioning.auth.tls.keystore The secret key from the certificatesSecret if 'keystore' key different from the default (keystore.jks)
      ##
      keystore: keystore.jks
      ## @param provisioning.auth.tls.truststore The secret key from the certificatesSecret if 'truststore' key different from the default (truststore.jks)
      ##
      truststore: truststore.jks
      ## @param provisioning.auth.tls.passwordsSecret Name of the secret containing passwords to access the JKS files or PEM key when they are password-protected.
      ## It should contain two keys called "keystore-password" and "truststore-password", or "key-password" if using a password-protected PEM key.
      ##
      passwordsSecret: ""
      ## @param provisioning.auth.tls.keyPasswordSecretKey The secret key from the passwordsSecret if 'keyPasswordSecretKey' key different from the default (key-password)
      ## Note: must not be used if `passwordsSecret` is not defined.
      ##
      keyPasswordSecretKey: key-password
      ## @param provisioning.auth.tls.keystorePasswordSecretKey The secret key from the passwordsSecret if 'keystorePasswordSecretKey' key different from the default (keystore-password)
      ## Note: must not be used if `passwordsSecret` is not defined.
      ##
      keystorePasswordSecretKey: keystore-password
      ## @param provisioning.auth.tls.truststorePasswordSecretKey The secret key from the passwordsSecret if 'truststorePasswordSecretKey' key different from the default (truststore-password)
      ## Note: must not be used if `passwordsSecret` is not defined.
      ##
      truststorePasswordSecretKey: truststore-password
      ## @param provisioning.auth.tls.keyPassword Password to access the password-protected PEM key if necessary. Ignored if 'passwordsSecret' is provided.
      ##
      keyPassword: ""
      ## @param provisioning.auth.tls.keystorePassword Password to access the JKS keystore. Ignored if 'passwordsSecret' is provided.
      ##
      keystorePassword: ""
      ## @param provisioning.auth.tls.truststorePassword Password to access the JKS truststore. Ignored if 'passwordsSecret' is provided.
      ##
      truststorePassword: ""
  ## Kafka provisioning pods ServiceAccount
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  ##
  serviceAccount:
    ## @param provisioning.serviceAccount.create Enable creation of ServiceAccount for Kafka provisioning pods
    ##
    create: true
    ## @param provisioning.serviceAccount.name The name of the service account to use. If not set and `create` is `true`, a name is generated
    ## If not set and create is true, a name is generated using the provisioning.serviceAccount.name template
    ##
    name: ""
    ## @param provisioning.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ## Can be set to false if pods using this serviceAccount do not need to use K8s API
    ##
    automountServiceAccountToken: false
  ## Kafka provisioning resource requests and limits
  ## ref: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  ## @param provisioning.resourcesPreset Set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if provisioning.resources is set (provisioning.resources is recommended for production).
  ## More information: https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15
  ##
  resourcesPreset: "small"
  ## @param provisioning.resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
  ## Example:
  ## resources:
  ##   requests:
  ##     cpu: 2
  ##     memory: 512Mi
  ##   limits:
  ##     cpu: 3
  ##     memory: 1024Mi
  ##
  ## resources: {}
  ## Kafka provisioning pods' Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param provisioning.podSecurityContext.enabled Enable security context for the pods
  ## @param provisioning.podSecurityContext.fsGroupChangePolicy Set filesystem group change policy
  ## @param provisioning.podSecurityContext.sysctls Set kernel settings using the sysctl interface
  ## @param provisioning.podSecurityContext.supplementalGroups Set filesystem extra groups
  ## @param provisioning.podSecurityContext.fsGroup Set Kafka provisioning pod's Security Context fsGroup
  ## @param provisioning.podSecurityContext.seccompProfile.type Set Kafka provisioning pod's Security Context seccomp profile
  ##
  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001
    seccompProfile:
      type: "RuntimeDefault"
  ## Kafka provisioning containers' Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  ## @param provisioning.containerSecurityContext.enabled Enable Kafka provisioning containers' Security Context
  ## @param provisioning.containerSecurityContext.seLinuxOptions [object,nullable] Set SELinux options in container
  ## @param provisioning.containerSecurityContext.runAsUser Set containers' Security Context runAsUser
  ## @param provisioning.containerSecurityContext.runAsGroup Set containers' Security Context runAsGroup
  ## @param provisioning.containerSecurityContext.runAsNonRoot Set Kafka provisioning containers' Security Context runAsNonRoot
  ## @param provisioning.containerSecurityContext.allowPrivilegeEscalation Set Kafka provisioning containers' Security Context allowPrivilegeEscalation
  ## @param provisioning.containerSecurityContext.readOnlyRootFilesystem Set Kafka provisioning containers' Security Context readOnlyRootFilesystem
  ## @param provisioning.containerSecurityContext.capabilities.drop Set Kafka provisioning containers' Security Context capabilities to be dropped
  ## e.g:
  ##   containerSecurityContext:
  ##     enabled: true
  ##     capabilities:
  ##       drop: ["NET_RAW"]
  ##     readOnlyRootFilesystem: true
  ##
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop: ["ALL"]
  ## @param provisioning.waitForKafka If true use an init container to wait until kafka is ready before starting provisioning
  ##
  waitForKafka: true
  ## @param provisioning.useHelmHooks Flag to indicate usage of helm hooks
  useHelmHooks: true

## KRaft configuration
## Kafka mode without Zookeeper. Kafka nodes can work as controllers in this mode.
##
kraft:
  ## @param kraft.enabled Switch to enable or disable the KRaft mode for Kafka
  ##
  enabled: true
  ## @param kraft.existingClusterIdSecret Name of the secret containing the cluster ID for the Kafka KRaft cluster. This is incompatible with the clusterId parameter. If both are set, the existingClusterIdSecret will be used
  existingClusterIdSecret: ""
  ## @param kraft.clusterId Kafka Kraft cluster ID. If not set, a random cluster ID will be generated the first time Kraft is initialized.
  ## NOTE: Already initialized Kafka nodes will use cluster ID stored in their persisted storage.
  ## If reusing existing PVCs or migrating from Zookeeper mode, make sure the cluster ID is set matching the stored cluster ID, otherwise new nodes will fail to join the cluster.
  ## In case the cluster ID stored in the secret does not match the value stored in /bitnami/kafka/data/meta.properties, remove the secret and upgrade the chart setting the correct value.
  ##
  clusterId: ""
  ## @param kraft.controllerQuorumVoters Override the Kafka controller quorum voters of the Kafka Kraft cluster. If not set, it will be automatically configured to use all controller-elegible nodes.
  ##
  controllerQuorumVoters: ""

## @section ZooKeeper chart parameters
zookeeper:
  ## @param zookeeper.enabled Switch to enable or disable the ZooKeeper helm chart. Must be false if you use KRaft mode.
  ##
  enabled: false
